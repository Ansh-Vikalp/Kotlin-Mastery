package OOPM

/*
    In Kotlin Getters and Setters are the meathods
    setter is used to set the value of any property and getter is used to get the value
    getter and setter are auto-generated for each class property by compiler if not defined explicetely

    You can create own implementation of getter and setter if you want extra work to validate or check input before assigning it to
    any property. Ex- if age is <=0 show some error

    If a property/variable is defined with val keyword means it can't be changed once it been initialized by default value in class body
    so compiler doesn't generate setter for it and you too.
    To use a property in class body, simply refer to it by its name, to use outside of class by creating object of that class.

    The getter and setter need to be defined just below the property.
    Syntax-

    var empId: String = "default_id"
    get()= field
    set(value){
        field = value
    }

    When you use a property like println(emp.name), println(emp.addrress) inside main(), to ye property ki value Kotlin mai
    direct access nahi hoti hai vale aapko esa lagta ho. Yani property ko jab aap access kar rahe hote ho to by default
    getter call ho raha hota hai. same tarike se jab aap property ko main() me set karte ho like- emp.name= "Ramesh" emp.address="LapataGanj" to setter call hota hai
    Agar aapne gette and setter nahi bana rakha hai explicitely to auto-generated setter getter call hoga.

    Ye bat aap es tarijke se verify kar sakte ki-
    var totala= "varsolika"
    get(){
        println("Getter called")
        return field
    }
    set(value){
        println("Setter called")
        field= value
    }

    fun main(){
        val obj= Demo()
        obj.totala="BarmundaburKumar"// op- setter get called
        println("obj.totala") //op- getter get called \n BarmundaburKumar
    }
 */

class Address {
    var name: String = "Holmes, Sherlock" // getter and setter auto generated by compiler
    var street: String = "default_street" // we can explicetely define getter and setter also
        get() = field // if getter contains single statement then return feild  and {} can be removed
        set(value) {
            field = value // field is a keyword that points to the property
        }

    var city: String = "London"
        get(){// for many statements we need a block
            println("getter called")// wherever we use this property then we are not accessing them directly, it is accessible only by getter
            return field
        }
        set(value){
            println("setter called")
            field= value
        }
    var state: String? = "default_state"
        get()= field
        set(value) { // main purpose of user defined setter is to check value before assigning
            if (value == null) {
                println("state can't be null")
            }else{
                field= value
            }
        }

    //The property type is optional if it can be inferred from the default_initializer or the getter's return type, as shown below:
    var zip1= 123456
    val zip2 // type is decided by the getter's return type
        get()= this.zip1 - 677
    //zip 2 is val so we or compiler can't create setter for it
}

fun main() {

    val ob: Address = Address()
    println(ob.name)
    println(ob.street)
    ob.city="San Francisco" //setting
    println(ob.city) // getting

    ob.state= null // custom setter for state is called
    println(ob.state)// custom getter for state is called
    println(ob.zip1)
    println(ob.zip2)
}